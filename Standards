1 Code Formatting
Line length should be 120 characters in length. Lines longer than this length should be formatted as per the line splitting guidelines provided in Sun's Java Standards.
Indentation should be 4 spaces. Code should not be checked in with tabs
2 Blank Lines
Blank lines improve readability by setting off sections of code that are logically related. One blank line should always be used in the following circumstances: 

Between methods
Between the local variables in a method and its first statement
Before a block or single-line comment
Between logical sections inside a method to improve readability
3 Blank Spaces
A keyword followed by a parenthesis should be separated by a space.
The expressions in a for statement should be separated by blank spaces.
Casts should be followed by a blank space.
There should not be any trailing spaces after the statement
4 Comments
Javadoc comments should follow the [SunGuidelines]. The following section gives certain Dos and Don't of the Java doc comments

Dos
Add a class level Javadoc comment on all classes, including private classes. It should explain the role of the class, important relationships to other classes and important characteristics of the class that a user of it should know (is it expensive to create, thread safety etc.)
Document all public methods. For each method
Document range of valid argument values
Document preconditions and post conditions
Document expected behavior and state transitions
Document exceptions
Public constant fields should have Javadoc comments.
Use inline comments to explain ''why'' something is written as it is, not ''how''. In some non trivial algorithms it may really be necessary to explain how something is working
Keep comments up to date: The only thing worse than not having comments is to have a misleading and out of date comments. When you change the code, you must update the comments to reflect any changes in the code.
Use the Java Doc Tags:  (@param, @return, @deprecated, @since, @throws, @exception, @see)
Provide link to useful information using @see tag
Use @link to create links to JavaDoc of other classes: "This acts as a proxy to a {@link MyDataService} instance."
Use HTML tags for formatting, <p> for paragraphs, <pre> for preformatted text
Escape special HTML characters as entities (&amp; for &, &lt; for <, &gt; for >)
Use <code></code> for code snippets
Dont's
Don't state the obvious: Delete comments that restate the obvious without adding information about why the code does what it does.The best API names are "self-documenting", meaning they tell you basically what the API does. If the doc comment merely repeats the API name in sentence form, it is not providing more information.. At the same time, you should be aware that what is obvious to you as the author may not be obvious to others.
Don't keep IDE Generated comment stubs : Do not leave out the comment stubs generated by IDE. They are blank templates for you to fill but they carry no information unless you fill them.
Don't keep commented out code : Commented out code adds no value in an environment where there is a proper version control system in place. Do not leave out commented code. You can always get the older copy from the version control system. There may be instances where you have temporarily commented out code but it should never remain in your code for more than few days.
Don't make spelling mistakes in comments: Comments are for humans. Compiler doesn’t care for the spellings of any token except keywords but humans do
Do not add opinions to public Javadocs such as "I don't like it but this hack is necessary for this method to work"
5 Organizing your source file
The organization of content in your file is an important criteria in determining how readable your code is. In a carefully organized file, one can very easily find the relevant information without having to go through the entire code.

Element (ordered)
Guideline
Header
A standard header should be provided at the top of every source file that forms part of the project. Refer to Instructions for adding standard header
Import statements (if any)
Remove all unused import statements
Do not use import wildcards (package.subpackage.*) since these make it difficult to see what classes a particular piece of code is using - instead use explicit imports for classes.
Group import statements into logical groups to improve readability and understanding of your code.
Class/interface documentation comment

(/**...*/) 
Documentation comments are meant to describe the specification of the code, from an implementation-free perspective. to be read by developers who 
might not necessarily have the source code at hand. These become part of the Java Doc of the class/interface
class or interface statement

 
[ClassModifiers] class ClassName [Inheritances] { 
ClassBody 
} 

[ClassModifiers] are any combination of the following keywords, in this order: public abstract final 

[Inheritances] are any combination of the following phrases, in this order: extends SuperClass implements Interfaces
Class/interface implementation comment, (if any)

(/*...*/)
Implementation comments are meant for comments about the particular implementation. This comment should contain any class-wide or 
interface-wide information that wasn’t appropriate for the class/interface documentation comment. 

These do not become part of the Java Doc of the class/interface
Class ( static) variables
First the public class variables, then the protected, then package level (no access modifier), and then the private.
Instance variables
First public, then protected, then package level (no access modifier), and then private.
Static Initialization block
Static block
Constructors
If multiple constructors are present, the one with lower number of argument should be placed first.
Methods
These methods should be grouped by functionality rather than by scope or accessibility 
[MethodModifiers] ReturnType MethodName(Parameters) [throws Exceptions] {

MethodModifiers are any combination of the following phrases, in this order: public protected private abstract static final synchronized native 

Exceptions is a comma-separated list of exceptions sorted in lexical order. 

Parameters is the list of formal parameter declarations. Parameters may be declared final in order to make the compiler enforce that the parameter is not changed in the body of the method. 

If type parameters are used in method, the type variable should be placed immediately before the return type. For example 

public static <T> void sort(List<T> list, Comparator<? super T> c)
Inner classes
Inner classes can be put in the end of the class body. If the class body is large, you can also place the inner classes near to the place they are being used.
6 Naming Conventions
Class and interface names should be nouns.
Class and interface should not contain prefixes to differentiate them from third-party classes. Java’s packaging mechanism is designed to obviate namespace clashes
Method names should be a verb in lowercase or a multi-word name that begins with a verb in lowercase, followed by adjectives, nouns, et
Methods names for accessors should be prefaced by get and mutators should be prefaced by set (e.g., getPhoneNumber or setPhoneNumber). Accessors that return boolean values should be named such that they represent interrogative statements (e.g., isRunning or containsPoint).
Name should be informative. The name should provide concrete information about the entity. Even before you read the implementation, the name itself should given an approximate idea of what the entity does.
Name should not be misleading. The name of an entity should not mislead the reader to expect something different compared to what the entity actually does.
Distinct words in a name should be separated by capitalization
Single letter variable names should be avoided except as local variables of loop.
The names should conform to Java coding convention for naming
Type
Guideline
Example
Packages
The prefix of a unique package name is always written in all-lowercase ASCII letters.
com.gs.report.HTML
Class/interface
Class/Interface names should be nouns, in mixed case with the first letter of each internal word capitalized. 
Try to keep your class names simple and descriptive. Use whole words-avoid acronyms and abbreviations 
(unless the abbreviation is much more widely used than the long form, such as URL or HTML
Filter 
Product 

PurgeTables
Method
Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.
public void validateTransaction() 

public int getAge()
Variables
Mixed case with a lowercase first letter. Internal words start with capital letters. Variable names should not start with 
underscore _ or dollar sign $ characters
double dollarValue 

$value 
int PRIMEid
Constants
The names of variables declared class constants should be all uppercase with words separated by underscores..
public static final int ACCOUNT_REASON_CODE = 3
Generic Type parameters
type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions 
that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference 
between a type variable and an ordinary class or interface name.
E - Element (used extensively by the Java Collections Framework) 
K - Key 
N - Number 
T - Type 
V - Value 
S,U,V etc. - 2nd, 3rd, 4th types
Enums	
Enums should follow the conventions for types(class/interface). Enum type name should be singular.

 Instances of an enum are constants and should follow the conventions for constants i.e. uppercase. 
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY 
}
7 Miscellaneous conventions
Open braces to start a block appear on the same line as the if/then/else/while/... statement.
Only one declaration per line is allowed.
Each line should contain no more than one statement.
Braces are used around all statements, even single statements, when they are part of a control structure, such as a if-else or for statement. This makes it easier to add statements without accidentally introducing bugs due to forgetting to add braces.
Use parentheses liberally in expressions involving mixed operators to avoid operator precedence problems
If an expression containing a binary operator appears before the ? in the ternary operator, it should be parenthesized for clarity e.g.  return (age > other.age) ? 1 : -1;
You should not add more than one public class in the same file.
Avoid local declarations that hide declarations at higher levels
Use Java predefined annotation types to annotate your code
Use @Override annotation when overriding methods. This annotation informs the compiler that the element is meant to override an element declared in a superclass. Compiler will make sure you actually are overriding a method when you think you are. This saves you from common mistakes like misspelling a method name or not correctly matching the parameters, 
Do not suppress warning using @SuppressWarnings annotations unless you have no way to resolve the warning. 
Use @Deprecated annotation to indicate that the marked element is deprecated and should no longer be used. In the JavaDoc of the method, add @deprecated tag with explanation on why is it deprecated and what is the alternative to this method
Use @SafeVarargs to assert that the code does not perform potentially unsafe operations on its varargs parameter


Coding Best Practices
1 Organization of codebase
1.1 Favour reuse over copy/paste
When you copy/paste source code, you end up having multiple individual copies of the same program. Each copy needs to be reviewed, tested and maintained independently. The fixes, improvements or feature additions to common code in one copy are not available to other copies of the code in the codebase. The practice of copy paste can lead to heavily bloated codebase where dozens of copies of same programs are going around in different parts of the codebase. Reusability of the code is not just a matter of moving code to a common module/class. The reusable code need to be of very good quality because the defects in heavily used code has impact on multiple application. Reusability also requires you to consider many aspects like ease of use, parameterization, documentation etc. You should consider possibilities of using reusable code instead of writing it on your own. At the same time, you also think of making the programs you write reusable. In both these cases, consult the TAs to promote better reusability.

1.2 Minimize the dependencies between logical units.
The packages should contain a set of classes that perform similar types of activities. You need to give proper attention while designing correct package dependencies. The dependency between packages arises from the fact that the classes placed in certain packages. Hence, it is important to consider where you place each class. When a package P1 depends on package P2, changes in classes in P2 may impact P1. You should try to avoid cyclic dependencies in package. Suppose there is a package com.shop.order.delivery that contains classes related to delivery or orders. There is another package that handles the com.shop.order.pricing that contains price calculation. Suppose a utility class CurrencyConverter has been incorrectly placed in com.shop.order.delivery. If this class is reused in com.shop.order.pricing package, this package will depend on com.shop.order.delivery when there should have been no logical dependency. The correct way would be to move the utility class in a separate package com.shop.util on which both pricing and delivery package can depend.

A good package design should strive to make the dependencies explicit, minimal and uni-directional

1.3 Remove unused and redundant code
During the lifecycle of any application, a part of codebase becomes unused and dead code. It is important to keep your source code free of dead code because large codebases are more difficult to maintain. After few years of application's life, it becomes difficult to find out what is being used and what can be safely removed. The dead code is rarely maintained by the team, it often has worse quality metrics than useful code and it brings down overall quality metrics. One of the important benefit of using version control systems is that you can restore deleted dead code if it becomes relevant at future point of time.  If you're removing some functionality, remove all traces of it from the codebase. In particular, you should pay attention to

Unused local variables/fields
Commented out code
Unused private/public methods
Unused classes/packages
2 Constants

2.1 Constants should be declared static and final
Without final modifier a variable is changeable and it is not constant, by definition. The static modifier causes the variable to be available without loading an instance of the class where it is defined.

2.2 Do not inherit interfaces containing only constants
An interface acts as a type that can be used to refer to instances of the classes implementing the interface. Constant interfaces violate this principle and should not be used. Many programmers write all the constants in interfaces and inherit their classes from these constant interfaces to avoid having to write InterfaceName.CONSTANT_NAME. This practice is conceptually flawed and should not be used. For more on this, refer to "Item 17: Use interfaces only to define types " in Effective Java

2.3 Do not use values for the concepts that have well defined constants
//TODO: Fix this
double area = 3.14159 * Math.pow(radius, 2);   
//NOTE: Not only is the value given above is less precise than it should be, it makes the code less redable
double area = Math.PI * Math.pow(radius, 2);
2.4 Use constants for the concepts from business domain that have fixed values
Do not use magic numbers. Create constants with meaningful names

//TODO: Fix this
if (age < 18) { 
// reject application 
}
 
//NOTE: 18 is a magic number. You should create a constant here
public static final int MINIMUM_AGE = 18;
if (age < MINIMUM_AGE) {
// reject application 
}
2.5 Use java enum to group related constants
You should avoid creating a single Constants file containing large number of unrelated constants.You should use enum types any time you want to restrict possible values to a fixed set of constants. 

//TODO: Fix This
public static final int CONVERTIBLE_BOND = 1; 
public static final int NON_CONVERTIBLE_BOND = 2; 
public static final int EXCHANGEABLE_BOND= 3;
public static final int CONVERTIBLE_PREFERREDS = 4;
 
//NOTE: This can be changed to use Enums.
public enum ProductClass {
    CONVERTIBLE_BOND,
    NON_CONVERTIBLE_BOND,
    EXCHANGEABLE_BOND,
    CONVERTIBLE_PREFERREDS 
}
 
//Usage of enums have another advantage. You can create a named subset of these Enum values
public static final Set<ProductClass> CONVERTIBLE_INSTRUMENTS = EnumSet.of(CONVERTIBLE_BOND,CONVERTIBLE_PREFERREDS);
2.6 Use static imports sparingly
Here is a useful advice from Java documentation on when to use static imports. "Only use it when you would otherwise be tempted to declare local copies of constants, or to abuse inheritance (the Constant Interface Antipattern). In other words, use it when you require frequent access to static members from one or two classes. If you overuse the static import feature, it can make your program unreadable and un-maintainable, polluting its namespace with all the static members you import. Readers of your code (including you, a few months after you wrote it) will not know which class a static member comes from. Importing all of the static members from a class can be particularly harmful to readability; if you need only one or two members, import them individually. Used appropriately, static import can make your program more readable, by removing the boilerplate of repetition of class names."

The name of the class in a static method call helps resolve the ambiguity on where the method is declared. When the method name is unambiguously associated with a familiar class, it may be correct to use static import. Some examples for such methods are JUnit asserts or functions from java.lang.Math. Here the statement assertTrue(cftcCodes.size() == 2) may be as clear to the reader as Assert.assertTrue(cftcCodes.size() == 2). Hence it's fine to use static imports. 

On the other hand, a method getInstance() does not give any indication of where this method may have been declared because getInstance is a commonly used method name in various singleton classes. Hence the following static import is incorrect.
import static java.text.DateFormat.getInstance;

3. Variables
3.1 Minimize scope of variables
A variable should be declared in such a way that its scope is cut down to bare minimum. If it is supposed to be used only inside the loop or a conditional block, it should be declared inside the block. If a variable is used in the condition expression, you can initialize it immediately before the condition block.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
//TODO: Fix this
int sum = 0;
………………………….
………………………….
………………………….
………………………….
int i;
for (i = 0; i < values.length; i++) {
    sum += values[i];
}
 
//NOTE: Here the variable sum is declared many lines before it is first used. It can be moved closer to the block where it is computed. Similarly, variable i can be moved inside the block
………………………….
………………………….
………………………….
………………………….
int sum = 0;
for (int i = 0; i < values.length; i++) {
    sum += values[i];
}
3.2 Do not reuse same variable for different concepts in the same method
If a variable represents a concept, it should not be reused to mean something else in the same method. Do not change input parameter values because it create confusion between the supplied inputs and current values of the variables.

//TODO: Fix This
public double getNetEarning() {
    double earning = getRevenue();
    earning = earning – getExpenses();
    earning = earning – getInterest();
    earning = earning – getDepreciation();
    earning = earning – getTax();
    return earning;
}
 
//NOTE: In the above example, the meaning of the variable earning is changing. You should create different variables
public double getNetEarning() {
    double revenues = getRevenue();
    double operatingProfit = revenues – getExpenses();
    double ebitda = operatingProfit – getInterest();
    double earningsBeforeTax = ebitda – getDepreciation();
    double earningsAfterTax = earningsBeforeTax – getTax();
    return earningsAfterTax;
}
4 Conditional Blocks
4.1 Complex conditional expressions must be broken down
Complex boolean expressions should be broker down into readable expressions. Use local variables to represent the value of sub-expression 

//TODO: Fix This
if (expiryDate.after(businessDate) && (lastTradeDate.equals(businessDate) || lastTradeDate.after(businessDate))) {
      // handle
}
 
//NOTE: In the above if block, the expression can be simplified
boolean isActive = expiryDate.after(businessDate);
boolean isTraded = lastTradeDate.equals(businessDate) || lastTradeDate.after(businessDate);
if (isActive && isTraded) { 
    // handle
}
4.2 Simplify the expressions where possible
You should use boolean logic to reduce the expression to as simple as possible. The rules of Boolean algebra are so simple that these can be put in the one table given below. However, many developers ignore these simple rules and create unreadable expressions

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
x || (y || z) == (x || y) || z          //Associativity of   OR  
x && (y && z) == (x && y) && z          //Associativity of  AND 
x || y == y || x                        //Commutativity of   OR  
x && y == y && x                        //Commutativity of  AND 
x && (y || z)== (x && y) || (x && z)    /Distributivity of  AND  over  OR 
x || false == x                         //Identity for  OR 
x && true == x                          //Identity for  AND 
x && false == false                     //Annihilator for  AND 
x || x == x                             //Idempotence of  OR 
x && x == x                             //Idempotence of  AND 
x && (x || y) == x                      //Absorption 1
x || (x && y) == x                      //Absorption 2
x || (y && z) == (x || y) && (x || z)   //Distributivity of  OR  over  AND 
x || true == true                       //Annihilator for  OR 
x && !x == false                        //Complementation 1
x || !x == true                         //Complementation 2
!(!x) == x                              //Double negation
!x && !y == !(x || y)                   //De Morgan 1
!x || !y == !(x && y)                   //De Morgan 2
4.3 Redundant conditional blocks should be removed
//TODO : Fix This
boolean isValid = false;
if (action.equals(INCLUDE)) {
    if (codeList.contains(futureCode))
        isValid = true;
    else
        isValid = false;
    } else if (action.equals(EXCLUDE)) {
        if (codeList.contains(futureCode))
            isValid = false;
        else
            isValid = true;
}
 
//NOTE: If the variable isValid is initialized to false, the conditional blocks setting it to false are redundant
boolean isValid = false;
if (action.equals(INCLUDE)) {
    if (codeList.contains(futureCode)) {
        isValid = true;
    } else if (action.equals(EXCLUDE)) {
        if (!codeList.contains(futureCode)) {
            isValid = true;
        }
    }
}
 
//NOTE: Using the guidelines below, you can further simplifies this
boolean isValid = false;
if (action.equals(INCLUDE)) {
    isValid = (codeList.contains(futureCode));
} else if (action.equals(EXCLUDE)) {
    isValid = (!codeList.contains(futureCode));
}
 
//NOTE : Final version
boolean futureCodeInList = codeList.contains(futureCode);
boolean isValid = (action.equals(INCLUDE) && futureCodeInList) || (action.equals(EXCLUDE) && !futureCodeInList);
4.4 Do not use if else block when expression itself provides the value
//TODO : Fix This
private boolean isClosed(Calendar day) {
    if ((day.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) || (holidays.contains(day.getTime())))
        return true;
    else
        return false;
  
}
 
//NOTE: removal of if-else adds to readability here
private boolean isClosed(Calendar day) {
       int dayOfWeek = day.get(Calendar.DAY_OF_WEEK);
       boolean isHoliday = holidays.contains(day.getTime());
       return (dayOfWeek == Calendar.SUNDAY || isHoliday);
}
4.5 In if-else block, put normal case in "if " block and exceptional case in "else"
//TODO : Fix This
if (!valid){
    reportError();
} else {
    process();
}
 
//NOTE: Valid scenario is the normal case and hence goes in if block
if (valid){
    process();
} else {
    reportError();
}
4.6 Avoid putting executable statements in conditional expression
The statements in the conditional expressions should be boolean methods that check a condition but do not execute or update anything.

//TODO : Fix This
File folder = new File(path);
if (createDirectories && folder.mkdir()){
    LOG.info("Folder created successfully");   
}
 
//NOTE: The expression in the if block executes an action, when createDirectories flag is true. It is better to execute the action outside the conditional block
File folder = new File(path);
if (createDirectories) {
    boolean created = folder.mkdir();
    if (created) {
       LOG.info("Folder created successfully");   
    }
}
4.7 Consider simplifying multiple equality expressions joined with OR with constant set
At time you would find yourself dealing with a set of values that are used in conditional expressions. Instead of joining multiple equality checks with OR you can create a constant with a meaningful name and use to check if the supplied value belongs to this set. For Enums, you can use EnumSet.

//TODO : Fix This
if (color.equals(Color.RED)
    || color.equals(Color.BLUE)
    || color.equals(Color.GREEN)
    || color.equals(Color.YELLOW)) {
    // handle primary color
}
 
//NOTE: Here we can give a meaningful name of the set of colors we are dealing with and check for contains. 
Set<Color> PRIMARY_COLORS = EnumSet.of(RED,YELLOW,GREEN,BLUE);
if (PRIMARY_COLORS.contains(color)) {
    // handle primary color
}
4.8 Don’t use conditional blocks where polymorphism is a better approach
When you find yourself dealing with separate kind of objects in one method, you should consider using polymorphism.

//TODO : Fix This
public static double getArea(Shape shape) {
    List<Double> sides = shape.getSides();
    if (sides.size() == 3) {
        // Heron’s formula
        double halfPerimeter = 0;
        for (Double side : sides) {
            halfPerimeter += side / 2;
        }
        double value = halfPerimeter;
        for (Double side : shape.getSides()) {
            value = value * (halfPerimeter - side);
        }
        area = Math.sqrt(value);
    } else if (sides.size() == 4 && shape.isRectilinear()) {
        double value = 1;
        for (Double side : sides) {
            value = value * side;
        }
        area = Math.sqrt(value);
    }
    return area;
}
 
//NOTE: In the method above, we have mixed the computations related to multiple different shapes. We can use polymorphism here
public abstract class Shape {
    public abstract double getArea();
    public abstract double getPerimeter(); 
}
  
class Rectangle extends Shape {
    double length;
    double breadth;
  
    public double getArea() {
        return (length * breadth);
    }
  
    public double getPerimeter() {
        return 2 * (length + breadth);
    }
}
  
class Triangle extends Shape {
    List<Double> sides;
  
    public double getArea() {
        // Heron’s formula
        double halfPerimeter = getPerimeter() / 2;
        double value = halfPerimeter;
        for (Double side : sides) {
            value = value * (halfPerimeter - side);
        }
        return Math.sqrt(value);
    }
  
    public double getPerimeter() {
        double perimeter = 0;
        for (Double side : sides) {
            perimeter += side;
        }
        return perimeter;
    }
}
5. Loops
5.1 Do not use a combination of infinite loop and a break
The use of break and continue can reduce readability of the code. When the test condition for the loop is the necessary and sufficient criteria for the loop to continue, the loop can be proved to work(by mathematical induction). Arbitrary break and continue statements affect readability of the code and make debugging difficult.

//TODO : Fix This
public MeetingSlot findAvailableSlot(MeetingCalendar cal) {
    MeetingSlot freeSlot = null;
    while (true) {
        if (!cal.hasMoreSlots()) {
            break;
        }
        MeetingSlot slot = cal.nextSlot();
        if (slot.isFree()) {
            freeSlot = slot;
            break;
        }
    }
    return freeSlot;
}
 
//NOTE: The method above can be made more readable by removing the unconditional while. The condition now clearly states that exit when there are no more slots or a freeSlot has been found
public MeetingSlot findAvailableSlot(MeetingCalendar cal) {
    MeetingSlot freeSlot = null;
    while (cal.hasMoreSlots() && freeSlot == null) {
        MeetingSlot slot = cal.nextSlot();
        if (slot.isFree()) {
            freeSlot = slot;
        }
    }
    return freeSlot;
}
5.2 Avoid using continue excessively
The continue statement moves control to iteration without further progress through the loop body for the current iteration. In effect a continue statement allows you to conditionally skip the execution of rest of the statement for this iteration. The same result can be achieved with an "if" block with much better readability.

The only cases where continue may improve readability are the cases where there are multiple nested conditional blocks. Removing continue may add and extra if block. Such cases are rare in a well written code.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
//TODO : Fix This
public Element findChildElement(Node node, String name) {
    NodeList children = node.getChildNodes();
    for (int i = 0; i < children.getLength(); i++) {
        Node child = children.item(i);
        if (child.getNodeType() != Node.ELEMENT_NODE) {
            continue;
        }
        if (child.getNodeName().equals(name)) {
            return (Element) child;
        }
    }
    return null;
}
 
//NOTE: Notice that the continue statement in line 7 has been replaced by additional clause in if
public Element findChildElement(Node node, String name) {
    NodeList children = node.getChildNodes();
    Element child = null;
    for (int i = 0; child == null && i < children.getLength(); i++) {
        Node node = children.item(i);
        if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(name)) {
            child = (Element) node;
        }
    }
    return child;
}
6. Methods
6.1 Methods should be small
A method should be small. While the strict restriction on the size may not fit all scenarios, most methods should not be more than 20-25 lines. If the method is more than 100 lines, it is an indication that you are doing too many things in the method.

6.2 Do only one logical thing in a method
The key to writing modular code is to write methods that do one and only one logical thing. In case a method needs to perform a task that can be divided into multiple sub tasks, each sub task should be a function.

//TODO : Fix This
public class Account {
  double balance;
  
  public void processTransaction(Transaction transaction) throws InvalidTransactionException {
      if (transaction.getAmount() <= 0) {
          throw new InvalidTransactionException("Incorrect amount");
      }
      if (transaction instanceof Transfer && ((Transfer) transaction).getDestinationAccount() == null) {
          throw new InvalidTransactionException("Destination account missing");
      }
  
      if (transaction.getType() == TransactionType.DEBIT) {
          if (balance > transaction.getAmount()) {
              balance = balance - transaction.getAmount();
          } else {
              throw new InvalidTransactionException("InSufficient Balance");
          }
      } else if (transaction.getType() == TransactionType.CREDIT) {
          balance = balance + transaction.getAmount();
      } else if (transaction.getType() == TransactionType.CREDIT) {
          if (balance > transaction.getAmount()) {
              Account toAccount = ((Transfer) transaction).getDestinationAccount();
              balance = balance - transaction.getAmount();
              Transaction creditTo = new Transaction(toAccount,TransactionType.CREDIT, transaction.getAmount());
              toAccount.processTransaction(creditTo);
          } else {
              throw new InvalidTransactionException("InSufficient Balance");
          }
      }
  }
}
 
//NOTE: The actions for each of the transaction type can be moved to private methods
public void processTransaction(Transaction t) throws InvalidTransactionException {
    validateTransaction(transaction);
    switch (transaction.getType()) {
        case DEBIT:
            debit(transaction.getAmount());
            break;
        case CREDIT:
            credit(transaction.getAmount()));
            break;
        case TRANSFER:
            transfer(transaction.getDestinationAccount(),transaction.getAmount()));
            break;
    }
}
6.3 Use only one level of abstraction per method
A method represents a named abstraction that helps factor out implementation details of a task so that the programmer can focus on relevant concepts at a time.
If a method M does a task that can be broken into subtasks, you should not be implementing the subtasks in the body of the method M.

Consider the following algorithm which rearranges an array in such a way that all occurrences of even number will come before the occurrences of odd numbers.

Rearrange                :: loop through the array, maintain invariant P : All numbers[0..j-1] are EVEN & numbers[j .. i-1] are ODD
Maintain invariant P :: If number is odd, swap it with first occurrence of the even . Increment i
Swap                        :: use a temporary variable and interchange the values

The detail of how to swap is not at the same level of abstraction as the content of the method. If you remove this detail by moving it to a method "swap", it increases the readability of the method.

//TODO : Fix This
public static void arrange(int[] numbers) {
    int j = 0;
    for (int i = 0; i < numbers.length; i++) {
        if (numbers[i] % 2 == 0) {
            int temp = numbers[j];
            numbers[j] = numbers[i];
            numbers[i] = temp;
            j++;
        }
    }
}
 
//NOTE: The detail of how to swap is not at the same level of abstraction as the content of above method. If you remove this detail by moving it to a method "swap", it increases the readability of the method.
public static void arrange(int[] numbers) {
    int j = 0;
    for (int i = 0; i < numbers.length; i++) {
        if (numbers[i] % 2 == 0) {
            swap(numbers, i, j);
            j++;
        }
    }
}
  
private static void swap(int[] numbers, int i, int j) {
    if (i != j) {
        int temp = numbers[j];
        numbers[j] = numbers[i];
        numbers[i] = temp;
    }
}
6.4 Minimize the number of levels of indentation in a method
In each method an indentation level corresponds to the detail of one task. If you detail each subtask in the same method, the level of indentations in your method will increase. The number of indentation levels in your method should not be more than 2.

//TODO: Fix this
private boolean printOrderDetails() {
    boolean success = false;
    try {
        List<Customer> customers = customerDAO.getCustomers();
        for (Customer customer : customers) {
            List<Order> orders = customer.getOrders();
            if (!orders.isEmpty()) {
                printCustomerDetails(customer);
                for (Order order : orders) {
                    if (order.getStatus() == Status.PAID) {
                        printOrderDetails(order);
                        List<LineItem> lineItems = order.getLineItems();
                        for (LineItem lineItem : lineItems) {
                            printLineItemDetails(lineItem);
                        }
                    }
                }
            }
        }
        success = true;
    }
    catch (SQLException e) {
        Logger.error("Error retrieving data", e);
    }
    return success;
}
 
//NOTE: This method has 7 levels of indentation and it needs to be broken down into methods
private boolean printOrderDetails() {
    boolean success = false;
    try {
        List<Customer> customers = customerDAO.getCustomers();
        processCustomers(customers);
    } catch (SQLException e) {
        Logger.error("Error retrieving data", e);
    }
    return success;
}
 
 
private void processCustomers(List<Customer> customers) {
    List<Order> orders = customer.getOrders();
    if (!orders.isEmpty()) {
        printCustomerDetails(customer);
        processOrders(orders);
    }
}
 
 
private void processOrders(List<Order> orders) {
    for (Order order : orders) {
        if (order.getStatus() == Status.PAID) {
            printOrderDetails(order);
            processLineItems(order.getLineItems());
        }
    }
}
 
private void processLineItems(List<LineItem> lineItems) {
    for (LineItem lineItem : lineItems) {
        printLineItemDetails(lineItem);
    }
}
6.5 Methods should take a small number of arguments, ideally less than 3
If a method takes a large number of arguments, it affects the readability of the calling program. It makes it hard to judge what data the methods needs. When you see the method call, it’s difficult to see what data is being supplied to a method . If you method takes more than 3 argument it is a symptom of one of following problems

The method does too many things : If this is eh case, you should break down the method into smaller methods
The arguments describe different properties of same object: If this is the case, you can supply the object as parameter rather than supplying its attributes
The arguments have some functional dependency between them: In this case, you can remove dependent parameter because it can be computed
The method is using some arguments as output argument (see next section)
Each of these problems affects the readability of the program.

//TODO : Fix This
public int dateDifference(Date fromDate, Date toDate, List<Date> holidays, boolean ignoreHolidays)
  
//NOTE: Too many things in one method!. Split the method 
public int dateDifference((Date fromDate, Date toDate) 
public int dateDifferenceExcludingHolidays((Date fromDate, Date toDate, List<Date> holidays) 
// The latter can internally call the former and remove holidays between 2 dates
 
//TODO: Fix this
public static String setParameters(Date businessDate, Date asof, String queryName, TokenizedQueryProvider queryProvider, String propertyFile, Long cmId, Long srcId)
 
 
//NOTE: The arguments describe different properties of same object. The arguments contain parameters for a query. 
// The method internally converts these parameters into a Map. This suggests that the method should instead expect a Map 
public static String setParameters(TokenizedQueryProvider queryProvider, String queryName, Map parameters)
 
//TODO: Fix this
public boolean checkMinimumAge(Date dateOfBirth, int age) {
    //...
}
 
//NOTE: Arguments have functional dependency. Age can be determined from dateOfBirth. In fact, the supplied age is inconsistent with the dateOfBirth, it can cause issues.
public boolean checkMinimumAge(Date dateOfBirth) {
    //...
}
6.6 You should not use output arguments
Arguments to a function are intuitively seen as an input to the function. Similarly return type is used to denote the output of the function. You should avoid using arguments to represent output of the function. If your function returns more than one type of information, the return type can be structured as an object. Other option is redesign your objects in such a way that the method operates on the state of object.

There are exceptions to this rule especially in recursive methods where you may be passing accumulated result of computation till this point to the next call.

//TODO : Fix This. 
//This method take List<Contract> as input and returns data using 3 output arguments
//For each Contract, it creates a CbmContract and adds it to cbmContracts.
//For each Contract, it gets ContractTransaction and adds them to cbmContractTransactions.
//For each ContractTransaction it gets ContractTransactionLegs and adds them to cbmContractTransactionLegs.
protected void splitContract(final List<Contract> contracts, final List<CbmContract> cbmContracts, final List<CbmContractTransaction> cbmContractTransactions, final List<CBMContractTransactionLeg> cbmContractTransactionLegs, Timestamp inZ, Timestamp fromZ) {...}
 
 
//NOTE: It needs to be broken into multiple methods where the input to the methods should represent only the input and the return type should be used to represent the output of the method
//Conversion from List<Contract> to List<CbmContract> (and other equivalent objects) is a simple task which can be done using CaramelList.collect
protected List<ContractTransaction> getTransactionsForAllContracts(final List<Contract> contracts)
  
protected List<ContractTransactionLeg> getTransactionLegsForAllTransactions(final List<ContractTransactions> transactions)
6.7 Argument and return types should not be too specific
You should use relevant interfaces or base types in parameter type/return types in the method declaration. When you use a specific type (e.g HashMap) in place of a more generic type (e.g. Map), you are forcing the calling program to use a specific type. For instance, if a method takes HashMap, the caller can not pass an alternate Map implementation like TreeMap or UnifiedMap. Similarly, if you return a specific type, in place of a more generic type, you are losing the flexibility to use an alternate implementation for returned object. If you change, the object that you are returning from HashMap to TreeMap, the calling programs will have to change.

//TODO : Fix This
public ArrayList filterNonReportable(ArrayList products)
 
//NOTE: Both the argument and return type are too specific. This restricts the caller and the implementers to use specific types
public List filterNonReportable(List products)
6.8 Methods should not have undesired side effects
A method should do what its name suggests. It should not have side effects that aren't implied by its name and not documented in the Java Docs.

//TODO : Fix This
public class Fibonacci {
    private static Map<Integer, Long> fibCache = new HashMap<Integer, Long>();
     
    public static long fibonacci(int n) {
        validateArgument(n);
        Long value = fibCache.get(n);
        if (value == null) {
            value = computeFibonacci(n);
            fibCache.put(n, value);
        }
        return value;
    }
    private static Long computeFibonacci(int n) {
        return (n == 0 || n == 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);
    }
}
 
//NOTE: It seems that fibonacci(n) computes the result and returns it. However, it is internally caching the result for optimization and there is no information in the documentation that this is the case.
//The method either needs to change to avoid caching or it should document clearly that each call can lead to caching of the fibonacci numbers
public static long fibonacci(int n) {
    validateArgument(n);
    if (n > 1) {
        long secondLastFib = 0;
        long lastFib = 1;
        int currentNumber = 2;
        while (currentNumber <= n) {
            long currentFib = lastFib + secondLastFib;
            secondLastFib = lastFib;
            lastFib = currentFib;
            currentNumber++;
        }
        return lastFib;
    } else {
        return n;
    }
}
6.9 In overloaded methods, the order of arguments should be consistent
If you are using overloaded methods, the order of arguments in all the versions of the same method shouldn’t be different. A consistent ordering minimizes the chances of the arguments getting swapped by mistake.

//TODO : Fix This
public int execute(Date businessDate, Date asof, String queryName);
 
public int execute(Date asof, Date businessDate, String queryName, String schemaName);
 
 
//NOTE: The order of arguments in methods above is inconsistent. The second method takes one extra arguments but the order of first two argument is different in these methods. This is fixed below
public int execute(Date businessDate, Date asof, String queryName);
  
public int execute(Date businessDate, Date asof, String queryName, Long cmId, Long srcId);
6.10 Do not duplicate code in overloaded methods
In most cases, there would be significant similarity in the processing of the overloaded data. In such cases, do not duplicate common code

Move common code to a private method which is called from each overloaded copy of the same method
Call one overloaded method from the body of another method and creating appropriate arguments
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
//TODO : Fix This
public Document load(InputStream stream) {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = factory.newDocumentBuilder();
    return builder.parse(stream);
}
  
public Document load(File file) {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = factory.newDocumentBuilder();
    return builder.parse(new FileInputStream(file));
}
 
 
//NOTE: The code in line 3-4 of above is duplicated in both methods
public Document load(File file) {
    InputStream stream = new FileInputStream(file)
    return load (stream);
}
  
public Document load(InputStream stream) {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = factory.newDocumentBuilder();
    return builder.parse(stream);
}
// An even better alternative is to avoid overloaded method and use InputSource as an argument type. InputSource can wrap both InputStream and Reader objects
6.11 Keep the number of exit points from a method to a minimum
If a method has a large number of returns, it affects readability of the method. You should try to minimize the exit points from a method.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
//TODO : Fix This
public Direction getDirection(Point destination) {
    int dX = destination.getX() - this.getX();
    int dY = destination.getY() - this.getY();
    if (dX > 0 && dY == 0) {
        return Direction.EAST;
    } else if (dX > 0 && dY > 0) {
        return Direction.NORTH_EAST;
    } else if (dX == 0 && dY > 0) {
        return Direction.NORTH;
    } else if (dX < 0 && dY > 0) {
        return Direction.NORTH_WEST;
    } else if (dX < 0 && dY == 0) {
        return Direction.WEST;
    } else if (dX < 0 && dY < 0) {
        return Direction.SOUTH_WEST;
    } else if (dX == 0 && dY < 0) {
        return Direction.SOUTH;
    } else if (dX > 0 && dY < 0) {
        return Direction.SOUTH_EAST;
    } else {
        return Direction.HERE;
    }
}
 
//NOTE: The code above has too many returns. It is hard to see if all cases are covered. The code below shows how you can reduce the number of returns using a local variable.
public Direction getDirection(Point destination) {
    int dX = destination.getX() - this.getX();
    int dY = destination.getY() - this.getY();
    Direction result = Direction.HERE;
    if (dX == 0 && dY == 0) {
        result = Direction.HERE;
    } else if (dX == 0 || dY == 0) {
        result = getCardinalDirection(dX, dY);
    } else if (dX > 0) {
        result = dY > 0 ? Direction.NORTH_EAST : Direction.SOUTH_EAST;
    } else {
        result = dY > 0 ? Direction.NORTH_WEST : Direction.SOUTH_WEST;
    }
    return result;
}
 
//Returns one of teh 4 cardinal directions NORTH, SOUTH, EAST, WEST or null if none of inputs are zero
private Direction getCardinalDirection(int dX, int dY) {
    Direction result = null;
    if (dX == 0) {
        result = dY > 0 ? Direction.NORTH : Direction.SOUTH;
    } else if (dY == 0) {
        result = dX > 0 ? Direction.EAST : Direction.WEST;
    }
    return result;
}
 
//P.S. The code above is only for illustration purposes. There are better solutions for this and reader is encouraged to explore this
6.12 Access modifier of the method should be chosen carefully
You should choose the most restrictive access modifier that can serve your purpose. If you write a granular code, you will have a large number of small methods, a significant portion of your methods will be private, a few of them will have package level accesses and even fewer of those will be public. Keeping the access restricted results in less and well defined dependencies between classes, packages. It is easy to relax the access restrictions when required than restricted the accesses after these have been misused.

7. Classes
7.1 A class should have a well defined role
A class should have a well defined role. It should represent a real life entity or concept. Before writing a new class, you must have a clear idea of the roles and responsibilities of a class. You should also know about its relationships with other classes. You should document these in the class level comments so that you have a baseline to compare with as the class evolves to take ever larger responsibilities. When you see that the class has grown beyond its role, you can consider splitting the responsibilities with multiple classes.

7.2 All members of a class must have some logical relationship
The methods of a class represent its behavior. A well designed class will have logical relationship between its methods. A class should not be a collection of arbitrary methods, some related to each other and others placed in the class for no reason.

7.3 Do not do too many things in a class
A class should not be doing too many things. Its responsibilities should be limited. You should constantly look for scope for grouping the related behaviors into new classes and delegating the responsibilities to new classes.

7.4 All class members should be related to the class and accessed from the class
A class variable should not be used to store things that are unrelated to the class. It should not be used to store things that have any relationship with a particular instance of the class and the static variables should not be updated from the instance methods or constructors. A static field represents the things that are shared between instances of the classes. Similarly, the static methods represent the behavior associated with the class that can be shared across the instances.

The static members should be accessed using <Class Name>.<Member Name>. The instance should not be used to access static members.

7.5 All instance variable should represent properties of the entity represented by the class
A class represents an entity or concept. Hence, each instance member should represent a property the entity. Its instance variables must convey some information about a particular instance of the class.

//TODO : Fix This
public class StockCode {
    private static final String SEPARATOR ="::";
    private String ticker;
    private String exchangeCode;
    private String key;
  
    public StockCode(String ticker, String exchange) {
        this.ticker = ticker;
        this.exchangeCode = exchange;
        this.key = exchangeCode + SEPARATOR + ticker;
    }
  
    ///Public getter/setter for ticker, exchangeCode
}
 
//NOTE: key is not a property of the StockCode. It is a value derived from ticker and exchange code for some purpose. 
// Making key an attribute of the class forces you to update the key every time the property of the object changes.
// You may consider removing it as an attribute and adding a method to compute it based on ticker & exchange code.
 
public class StockCode {
    private String ticker;
    private String exchangeCode;
     
    public StockCode(String ticker, String exchange) {
        this.ticker = ticker;
        this.exchangeCode = exchange;
    }
  
    ///Public getter/setter for ticker, exchangeCode
    public String getKey() {
        return exchangeCode + SEPARATOR + ticker;
    }
}
 
//TODO : Fix This
class ProductDetails {
    // Atributes of a contact
    public String code;
    public String exchangeCode;
    public List<Holiday> holidays;
}
 
//NOTE: This class represents the details of the contracts. Each product is listed on an Exchange. Each exchange has some holidays in a year.
// But holidays are not related to the the product and can not be modeled as a property of ProductDetails object,
7.6 Minimize mutability
You should resist the urge for writing a set method for every get method you write. Immutable classes are easier to design, implement and use than mutable classes. They are less prone to errors. Even within a class which has some mutable state, you should carefully consider which fields change throughout the lifecycle of the object and which fields do not and you should provide update methods only when necessary.  

//TODO : Fix This
public class Triangle {
  
    public Triangle(double sideA, double sideB, int sideC) {
        //initialize
    }
    public double getSideA() {//get};
    public void setSideA(double side) {//set};
    public double getSideB() {//get};
    public void setSideB(double side) {//set};
    public double getSideC() {//get};
    public void setSideC(double side) {//set};
}
 
//NOTE: The class Triangle should not be mutable. The sides of a given triangle can not be changes independently of other sides. 
// Hence it does not make sense to provide setters for specific sides. With the current Triangle object, it is easy to make the triangle 
// "degenerate" if the new side value violates the rule of geometry that the sum of any two sides must be greater than the third side.
public class Triangle {
    private final double sideA;
    private final double sideB;
    private final double sideC;
    public Triangle(double sideA, double sideB, int sideC) {
        this.sideA = sideA;
        this.sideB = sideB;
        this.sideC = sideC;
    }
    public double getSideA() {//get};
    public double getSideB() {//get};
    public double getSideC() {//get}
}
7.7 Carefully choose relationships between classes
Your should be careful in choosing the relationships between classes

Before implementing inheritance check if subclass has "is a" relationship with superclass. A TextComponent is-a Component, ArrayList is-a List but it is questionable if Stack in java is-a Vector. The s
If is-a relationship check fails but you want to reuse code, you can think other ways to reuse common code, like extracting common code in a different class. 
You can use composition if the relationship is has-a relationship. e.g. FormField has-a Label and it has-a TextComponent
Superclasses should not unnecessarily expose its members and keep the protected members at minimum.

7.8 Do not violate contract of super type while inheriting
When you override a method or implement an interface, your should not violate the contract of the super type. Doing so can lead to errors that are hard to notice. Some noticeable examples of this occur in commonly overridden methods and these are listed below.

Override hashCode when overriding equals: The contract of the hashCode, states that "If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result" This implies that when you override equals, you must override hashCode. If you violate this, you can get serious errors with working with classes that rely on contract of hashCode(HashMap, HashSet etc)

Be careful not to violate contract of Comparable/Comparator Interface: The contract of compare method in Comparator interface is designed to ensure that the comparison is asymmetric and transitive. Classes that depend on comparison include the sorted collections TreeSet and TreeMap, and the utility classes Collections and Arrays, which contain searching and sorting algorithms.

//TODO: Fix this
// This class create a comparator that uses an order which is reverse of natural ordering of the type
public class ReverseComparator<T extends Comparable<? super T>> implements Comparator<T> {
    @Override
    public int compare(T o1, T o2) {
        return o2 == null ? 1 : o2.compareTo(o1);
    }
}
 
//NOTE: The contract of Compare to state that the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y
// sgn(expression) designates the mathematical signum function, which is defined to return one of -1, 0, or 1 according to whether the value of expression is negative, zero or positive.
// This implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception
// This is violated in the implementation above. Due to this means compare(1, null) would work but compare(null, 1) would give exception. Sorting a list {3,12,null} with this comparator would work but sorting list  {null,3,12}   // would give exception. The following code fixes this to have a consistent behavior
public class ReverseComparator<T extends Comparable<? super T>> implements Comparator<T> {
    @Override
    public int compare(T o1, T o2) {
        return o1 == null && o2 == null ? 0 : o2.compareTo(o1);
    }
}
7.9 Do not add large amount of code in initialization blocks
Initialization blocks contain a set of statements without any name to indicate what the code does. Hence, you should avoid adding large amount of code to initialization blocks.

Java provides two kinds of initialization blocks.

A static initialization block is a normal block of code enclosed in braces, { }, and preceded by the static keyword. Static initialization blocks run when class is loaded in JVM. A class may have multiple static initialization blocks which are called during class loading in the order that they appear in the source code.
Initializer blocks for instance variables look just like static initializer blocks, but without the static keyword. The Java compiler copies initializer blocks into every constructor
If you have static initialization blocks that compute values to be assigned static fields, you can use private static methods and call these in RHS of static field assignment. In the cases, where we static initialization blocks can't be avoided, you can minimize the code in the static block by creating a private static method and calling the method from a single static block. This technique has advantage in readability because the name suggests what you are trying to do during initialization.

Usage of instance initialization blocks(non static) should be avoided because they don't offer any advantage over constructors. Any common code that needs to be shared among constructors can be moved to private methods. In anonymous classes, programmers use instance initialization blocks because constructors aren't allowed. Even in these cases, a named class is better than anonymous class with instance initialization block for better readability.

7.10 While using nested classes, choose carefully between static and non-static

If you declare a nested class that does not need access to its enclosing class, put static modifier in the declaration thereby making it static rather than a non-static nested class(inner classes). In's important to understand various types of inner classes and use the appropriate type. Nested classes are divided into two categories: static and non-static.

Nested classes that are declared static are simply called static nested classes. Static nested classes do not have access to other members of the enclosing class.
Non-static nested classes are called inner classes. Inner classes have access to other members of the enclosing class, even if they are declared private. 
You can declare an inner class within the body of a method. Such a class is known as a local inner class.
You can also declare an inner class within the body of a method without naming it. These classes are known as anonymous inner classes. An anonymous class has access to the members of its enclosing class. It can also access local variables in its enclosing scope that are declared as final. You shoudl keep anonymous classes small in length because they can reduce readability if they are large.
// For example, java.util.HashMap contains a nested class Entry which contains a key value mapping. Each instance of this class represents one key value pair and does not need access to enclosing instance. Hence the class is declared static
public class HashMap<K, V> extends AbstractMap<K, V> implements Map<K, V>, Cloneable, Serializable {
    //Code omitted 
    static class Entry<K, V> extends MapEntry<K, V> { 
        //Code omitted 
    } 
}
8 Exception handling
8.1 Do not use Exceptions for normal processing
Exceptions signify error conditions. You should not write programs that always result in exceptions and you catch those exception

//TODO:  Fix this
// Skip n elements of the supplied array after the each included element. Include first
public static int[] skip(int[] numbers, int skipCount) {
    ArrayList<Integer> list = new ArrayList<Integer>();
    for (int i = 0; i < numbers.length; i++) {
        int index = i * (1 + skipCount);
        try {
            list.add(numbers[index]);
        } catch (ArrayIndexOutOfBoundsException e) {
            break;
        }
    }
    int[] result = new int[list.size()];
    int j = 0;
    for (Integer n : list) {
        result[j++] = n;
    }
    return result;
}
 
//NOTE: The crux of the problem here is that the programmer hasn’t put enough effort to calculate the size of the filtered array. He instead relies on a runtime exception to tell him when to stop. This can be rewritten as follows
public static int[] skip(int[] numbers, int skipCount) {
    int size = numbers.length;
    int newSize = 1 + ((size - 1) / (1 + skipCount));
    int[] filteredArr = new int[newSize];
    for (int i = 0; i < newSize; i++) {
        filteredArr[i] = numbers[i * (1 + skipCount)];
    }
    return filteredArr;
}
8.2 Do not swallow exceptions
Each Exception signals an error condition. If you catch and ignore the exception, you may end up hiding a potential defect. Such defects are very hard to detect. Even if the logic of your program requires you to ignore the exception, you must write a comment explaining the reason to ignore the exception. The code below is very dangerous because it the catch block catches the exception and just suppresses it. Execution of the program continues after the catch block, as if nothing had happened.

//TODO:  Fix this
private List<Order> readOrders(Reader input){     
    try {         
        //read orders from file...
    } catch (Exception ex){         
        ex.printStacktrace();
        return null;
    } 
}
 
//NOTE: There are multiple things wrong about this method. It swallows exceptions. It catches Exception rather than catching specific exception. 
private List<Order> readOrders(Reader input) throws IOException {     
    //read orders from file...    
}
8.3 Use exception chaining when you catch an exception and throw new one
In your methods if you catch a lower level exception and translate it into a new higher level exception, you should wrap the lower level exception in the exception you’re throwing so that the caller may get the full details of the error. This implies that when you create a custom exception, you should add a constructors that takes the root exception as an argument along with explanatory message.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
//TODO:  Fix this
try {
    //try to fetch data
} catch (SQLException e) {
    throw new CobraException("Unable to fetch data");
}
 
public class CobraException
    public CobraException(String message) {
        super(message);
    }
}
 
//NOTE: In line 5, the exception while throwing new exception, we are not propagating root cause of the exception. This is fixed in line 19.
try {
    //try to fetch data
} catch (SQLException e) {
    throw new CobraException("Unable to get data", e);
}
  
public class CobraException extends Exception {
    public CobraException (String message, Throwable cause) {
        super(message, cause);
    }
}
8.4 Provide sufficient detail of the error in the exception
Each class must provide sufficient details about the errors so that the caller can take appropriate exception. Wherever required, you should write your own exception subclasses to denote various categories of errors that can occur in the program. These exception classes must provide accessor methods to get the information.

8.5 Document unchecked exceptions in the method java documentation
When you use checked exceptions, the method signature wants the user the possible error conditions which the caller must guard against. When you use unchecked exception, the caller of the method may not have any information on what exceptions your method may throw. Hence it is very important to document the conditions under which the call to the method will result in a runtime exception

For instance, the JavaDoc of Iterator interface in Java explicit mention that NoSuchElementException can be thrown if the iteration has no more elements

E next() 
Returns: the next element in the iteration
Throws:  NoSuchElementException - if the iteration has no more elements

8.6 Do not throw top level exception classes, use an appropriate domain-specific subclass
Do not throw top level exception classes java.lang package(Exception,RuntimeException, Error, Throwable). When a class throws java.lang.Exception, the caller is forced to catch it. As Exception is superclass of all exceptions, it leads to inadvertently catching errors like NullPointerException and mask defects. You should create a domain specific subclass of Exception. During exception scenarios, you should set attributes on the exception that provide sufficient information about the exception. Your domain level exceptions can have inheritance hierarchies like any other class.

Example: UnknownHostException is thrown to indicate that the IP address of a host could not be determined. It extends from IOException. It takes the hostName as argument to the constructor.

8.7 Do not catch top level exception classes
Do not throw top level exception classes java.lang package(Exception, RuntimeException, Throwable). The application should not try to catch an Error because it indicates abnormal condition(e.g. OutOfMemoryError). As Throwable is a superclass of Error, it doesn't make sense to catch Throwable. Catching top level exceptions can mask errors and lead to incorrect diagnosis of the root cause.

 You should only catch specific exceptions thrown by the called program. In Java 7, you can use | operator to catch multiple exception types in a single catch block. 

There are some exceptions to this general rule. If you are writing framework code which calls custom components and you want to ensure graceful handling of exceptions, you may have to catch Exception. Similarly if you are calling a 3rd party library which throws top level exceptions, you may have no choice but to deal with top level exceptions. In such cases, you should catch the top level exception at a single point in application(e.g. main method/entry point to service/system boundary between your code and called 3rd party code).

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
//TODO Fix this
public class CustomerDAO {
    private Properties connectionProps;
    public CustomerDAO(Properties props) {
        this.connectionProps = props;
    }
    public Customer findCustomer(String customerId) {
        try {
            Connection connection = DAOFactory.createConnection(connectionProps);
            Statement statement = connection.createStatement();
            ResultSet resultset = statement.execute(getQuery(customerId.toLowerCase()));
            return createUser(resultset);
        } catch (Exception e) {
            throw new RuntimeException("The users does not exist");
        }
    }
}
 
//NOTE: There multiple things wrong with the above method. If the call customerId.toLowerCase() throws a NullPointerException or call to DAOFactory.createConnection throws a InitializationException, you would get misleading      // message that users doesn't exists. This method also fails to close resources.
8.9 Use finally clause to do cleanup
The finally block always executes when the try block exits. This ensures that the finally block is executed even if an unexpected exception occurs. But finally is useful for more than just exception handling — it allows the programmer to avoid having cleanup code accidentally bypassed by a return, continue, or break. Putting cleanup code in a finally block is always a good practice, even when no exceptions are anticipated.

If the statements in the finally block can throw a checked exceptions, it is important to catch this exception and log the exception rather than throwing it from finally block. For instance if the code in try block throws an exception ex1, finally block will get executed. If an statement in finally block throws another exception ex2, this would hide the exception ex1 thrown from the try block which is the root cause of the error.

In Java 7, you can use try-with-resources to simplify the code for releasing resources. The try-with-resources statement is a try statement that declares one or more resources. A resource is as an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implementsjava.lang.AutoCloseable, which includes all objects which implement java.io.Closeable, can be used as a resource.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
//Example: Always close resources in the finally block
public class CustomerDAO {
    private Properties connectionProps;
    public CustomerDAO(Properties props) {
        this.connectionProps = props;
    }
    public Customer findCustomer(String customerId) throws SQLException {
        Connection connection;
        Statement statement;
        ResultSet resultset;
        try {
            connection = DAOFactory.createConnection(connectionProps);
            statement = connection.createStatement();
            resultset = statement.execute(getQuery(customerId.toLowerCase()));
            return createUser(resultset);
        } finally {
            //close resultset, statement and connection in that order while checking for null. Log any exceptions while closing
            close(resultset, statement, connection);
        }
    }
}
 
 
//NOTE: Java 7, this is greatly simplified
    public Customer findCustomer(String customerId) {
        try (Connection connection = DAOFactory.createConnection(connectionProps);
                Statement statement = connection.createStatement();
                ResultSet resultset = statement.execute(getQuery(customerId.toLowerCase()));) {
            return createUser(resultset);
        }
    }
8.10 Carefully consider the implications of using checked/unchecked exceptions
You should carefully consider whether to use checked vs unchecked exceptions. While there is a significant debate in Java community on role of checked exceptions, there are some points that need to be considered. An unchecked exception indicates unrecoverable error. In a method that provides low level functionality, throwing unchecked exception may not be correct because the error may be recoverable. By throwing checked exceptions, you indicate to the caller of the API the possibilities of various kinds of errors. The caller may choose to handle it or simply propagate it upwards.Usage of unchecked exceptions for recoverable errors forces the callers to write defensive code because the method signature doesn't declare the exception.

Unchecked exceptions should be used to denote unrecoverable errors like incorrect configuration or violation of necessary preconditions. An example of this could be failure to find configuration properties during startup. All unchecked exceptions should be subclasses of RuntimeException class.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
//TODO: Fix this
public class ReportingProcess {
    public void initialize(Properties config) throws InvalidConfigurationException {
        boolean isValid = validate(config);
        if (!isValid) {
            throw new InvalidConfigurationException("Supplied configuration is invalid");
        }
        // initialize resources
    }
 
 
    public void execute() {
        File report = generateReport();
        EmailNotifier notifier = new EmailNotifier(config);
        try {
            notifier.sendEmail(report, config);
        } catch (RuntimeException re) {
            LOG.error("Failed to email report", re);
        }
        persistReport(report);
    }
}
 
public class InvalidConfigurationException extends Exception { /*....*/ }
 
public class EmailNotifier {
    public void sendEmail(File file, Properties config) {
        try {
            //Implement ...........
        }
        catch (Exception e){
            throw new RuntimeException("Unable to send email"):
        }
    }
}
 
//NOTE: The above code has multiple problems. InvalidConfigurationException exception is unrecoverable. It is an example where RuntimeException can be used
// EmailNotifier on the other hand is a generic utility. It does not know whether failure to send email is critical enough to fail the process. Hence it should use checked exceptions to indicate the caller about the error and let //the caller take a call on how to detail with it. Usage of unchecked exception by EmailNotifier forces the client to 
// So EmailNotifier has been changed to use checked exception EmailNotificationException
 
public class InvalidConfigurationException extends RuntimeException { /*....*/ }
public class EmailNotificationException extends Exception { /*....*/ }
 
public class EmailNotifier {
    public void sendEmail(File file, Properties config) throws EmailNotificationException {
        try {
            //Implement ...........
        }
        catch (AddressException | SendFailedException | MessagingException | IOException e){
            throw new EmailNotificationException ("Unable to send email", e):
        }
    }
}
8.11 Do not use return values for exception cases
A return value represents the result of successful processing of the method. The exceptional scenarios should be indicated using the exceptions.There could be cases where handling of an exception and recovering from it is part of the processing of the method.

//TODO : Fix This
public boolean login(String userId, String password) {
    boolean isSuccessful = false;
    try {
        isSuccessful = service.login(userId, password);
    } catch (ServiceUnavailableException e) {
        // Service unavailable. Deny access
    }
    return isSuccessful;
}
 
//NOTE: The method uses return value false for an exceptional scenario.
// The caller has no way to distinguish whether
// (a) The service returned false on login attempt
// (b) The service was unavailable
//
// The method should throw an exception.
public boolean login(String userId, String password) throws ServiceUnavailableException {
    return service.login(userId, password);
}
9. Logging
Here are important guidelines on logging

Use SLF4J APIs for all logging. This is the most recent java logging API, and attempt to tackle some of the issues with previous attempts at APIs like commons-logging. Slf4j is just the logging facade/api. You can choose to use a range of logging systems at runtime(e.g. log4j). You should take care to ensure that the clients of your library are not forced to use same logging systems at runtime(in maven, this can be accomplished by marking implementation dependency as "optional").
Declare the logger with the class where you have created it. Often programmers copy paste the statement from one class to another leaving the old class in the declaration. It created unnecessary dependency.
privatestaticfinalLogger LOG = LoggerFactory.getLogger(MyClass.class);
Construct all log statements using value replacement syntax, do not construct logging messages using string concatenation
log.debug("the {} database melted at {}", databaseName,meltdownTime);
Use code guards for any log statement with side effects.
// Because toXML() would generate garbage / do work but might not get logged
if(logger.isDebugEnabled()) {
    logger.debug("Request as XML = {}", request.toXML());
}
When logging the exception, ensure the full details of the exception are logged.
// DO NOT TO THIS: exception.toString() does not return the stack trace or nested exceptions
logger.error("An error occurred processing payment. Reference number is {}, Root cause is {}", payment.getReference(), e.toString());
// DO THIS: pass the full exception object to the logging API
logger.error("An error occurred processing payment.Reference number is {}", payment.getReference(), e);
//NOTE: In SLF4J 1.6 and later, the SLF4J API supports parametrization in the presence of an exception, assuming the exception is the last parameter.
Do not bundle your logging configuration file in your jar. It prevents config conflicts if your jar is included in someone else's application, and you cannot edit the logging config if it is bundled in an artifact.
Use appropriate Log levels
Info: Information that will be useful to the support team to confirm that the application is working correctly.
Debug: Information that may be useful to the support team or developers to diagnose why a problem occurred, or reproduce a production problem in a development environment. This information should not typically be needed if the application is working properly. It may include relevant content(keys, contents) of the input(data,request,messages) being processed.
Trace: Use this level if you are going to generate a ton of debugging log messages, which might interfere with debugging. It designates finer-grained informational events than the DEBUG
Error : Use this level for error events that might still allow the application to continue running e.g. failure to serve a specific request or parse a message
Fatal : Use this error very severe error events that will presumably lead the application to abort 
You should not use System.out.println or exception.printStackTrace() (unless your are writing a command line tool).
10 Comments
Javadoc and inline comments are vital for the maintenance of the code base. New classes must be commented, since it would be very difficult for code reviewers to follow otherwise. When working with existing code, don't skip the documentation if there is none already. Commenting new methods and fields will save the time of others when reviewing. In general, follow the Sun/Oracle Javadoc conventions but be prepared to modify the completeness of documentation based on the target audience. For example, we would expect a higher level of completeness for a public interface provided as a library to another technology team, than for an internal public interface. An internal public interface would deserve a higher level of documentation than a private method. Remember your target audience.

Write comments that provide information that could be useful to the developer using your code. A useful comments doesn’t state the obvious. For method calls, the comments should describe the inputs, the outputs, exceptions and the effect of the call. For classes, they should describe the purpose of the class and how it can be used. A complete description of guidelines on Java Docs is available on How to Write Doc Comments for the Javadoc Tool and it is recommended that you read it. 

In public API, lack of comments forces the users of the APIs to make assumptions or discover things by trial and error. You should consider the fact that they do not have the source code and hence they have no way to find out any other detail apart from the method and argument names. A public method without proper comments can become completely useless unless you have access to source code.  For instance, let’s take a method 

Node insertBefore(Node child, Node refChild) throws DOMException
The method takes two arguments both are of the type Node. If I use this method, I would be interested in knowing

Is the node to be inserted the first parameter or second?
Which node does it return?
What happens when I pass null as one of the parameters?
What are the invalid parameter values and what kind of errors would I get if I supply invalid arguments?
Without proper comments, the API user would be forced to learn by hit and try. Now read the JavaDoc of the method http://docs.oracle.com/javase/7/docs/api/org/w3c/dom/Node.html#insertBefore

Node insertBefore(Node newChild,
                Node refChild)
                  throws DOMException
Inserts the node newChild before the existing child node refChild. If refChild is null, insert newChild at the end of the list of children. 
If newChild is a DocumentFragment object, all of its children are inserted, in the same order, before refChild. If the newChild is already in the tree, it is first removed.
Note: Inserting a node before itself is implementation dependent.

11 Generics
11.1 Don’t use raw types in the code
"Each generic type defines a raw type, which is the name of the generic type used without any accompanying actual type parameters [JLS, 4.8]. For example, the raw type corresponding to List<E> is List. Raw types behave as if all of the generic type information were erased from the type declaration. For all practical purposes, the raw type List behaves the same way as the interface type List did before generics were added to the platform"~Effective Java

11.2 Use generic methods only for expressing dependencies among type of arguments/return type
Generic methods allow type parameters to be used to express dependencies among the types of one or more arguments to a method and/or its return type. If there isn’t such a dependency, a generic method should not be used.

//TODO:  Fix this
public <T extends UserRequest> void logRequest(String requestId, T requestObject) { 
    LOG.debug("Request {} recieved, details : {}", requestObject);
}
 
//NOTE: This method has only one argument and no return type. The restriction of the input type can be achieved using the input type of the parameter
public void logRequest(String requestId, UserRequest requestObject) { 
    LOG.debug("Request {} recieved, details : {}", requestObject);
}
 
//This method sets dependency between the two arguments, the interval in which to find a point and the point itself. Here the usage of generics is correct
class Intervals {
    public static <T extends Comparable<? super T>> boolean containElement(GenericInterval<T> interval, T point) {
        boolean contains = false;
        if (point != null) {
            contains = (interval.from == null || interval.from.compareTo(point) <= 0);
            contains = contains && (interval.to == null || interval.to.compareTo(point) > 0);
        }
    }
}
11.3 Consider generic classes to represent type dependency between class and its members
A generic class(or interface) represents dependencies among the type of the container and the types used in member declarations. For instance, a ArrayList<Integer> is an ArrayList of Integer. You can add only Integer (and its subtypes) to it and hence the signature of its add method must reflect this. It internally stores the elements in an variable of type Integer[]. Hence the declaration of such type dependencies is best expression using generic types.

//TODO:  Fix this
public class Interval {
    public final Comparable from;
    public final Comparable to;
    public Interval(Comparable from, Comparable to) {
        this.from = from;
        this.to = to;
    }
 
 
    public boolean contains(Comparable point) {
        //...
    }
}
 
//NOTE: The class above class represents a interval of a given type but lack of type safety can allow creating intervals with from and to of different type. You should make this class generic class
public class Interval<T extends Comparable<? super T>> {
    public final T from;
    public final T to;
    public Interval(T from, T to) {
        this.from = from;
        this.to = to;
    }
 
    public boolean contains(T point) {
        return Intervals.containElement(this, point);
    }
}
11.4 Use generic types to remove family of classes that differ only in type
Before generics, many design patterns called for creating a family of classes to deal with different types. For instance, a typical data access object pattern implementation will have DAO factories for different types of DAO object. Each DAO was a different class because it created a specific type. That results into a family of classes that differ only in type. All this clutter can be removed using generic classes

//TODO:  Fix this
public interface CustomerDAO {
    public int insertCustomer(Customer c);
  
    public boolean deleteCustomer(Customer c);
  
    public Customer findCustomer(String key);
  
    public Collection findCustomers(Criteria s);
  
    public boolean updateCustomer(Customer c);
}
  
public interface EmployeeDAO {
    public int insertEmployee(Employee c);
  
    public boolean deleteEmployee(Employee c);
  
    public Employee findEmployee(String key);
  
    public Collection findEmployees(Criteria s);
  
    public boolean updateEmployee(Employee c);
}
 
//NOTE: You can remove the family of DAO classes using a generic DAO class
public class GenerticDAO<T> {
    private Class<T> valueClass;
     
    public GenericDAO(Class<T> valueClass) {
        this.valueClass = valueClass;
    }
    
    public int insert(T c);
  
    public boolean delete(T c);
  
    public T find(String s);
  
    public Collection<T> find(Criteria s);
  
    public boolean update(T c);
}
11.5 Use bounded wildcards to make your API flexible
In the generic methods, sufficient care must be taken to ensure that the calling programs are not unnecessarily restricted by your method signature. To understand this, consider a collection of type Collection<Number>. All the objects of type Number and it subclasses can be added to this collection. Similarly all the objects retrieved from this collection can be added to a collection of type Collection<S> where S is super type of Number. If your argument types restrict the type parameter to be too specific, it restricts usability of your API.

Here are the excerpts from Guidelines for Wildcard Use

For purposes of this discussion, it is helpful to think of variables as providing one of two functions:

An "In" Variable : An "in" variable serves up data to the code. Imagine a copy method with two arguments: copy(src, dest). The src argument provides the data to be copied, so it is the "in" parameter.
An "Out" Variable : An "out" variable holds data for use elsewhere. In the copy example, copy(src, dest), the dest argument accepts data, so it is the "out" parameter.

Wildcard Guidelines:

An "in" variable is defined with an upper bounded wildcard, using the extends keyword.
An "out" variable is defined with a lower bounded wildcard, using the super keyword.
In the case where the "in" variable can be accessed using methods defined in the Object class, use an unbounded wildcard.
In the case where the code needs to access the variable as both an "in" and an "out" variable, do not use a wildcard.
These guidelines do not apply to a method's return type. Using a wildcard as a return type should be avoided because it forces programmers using the code to deal with wildcards.

//TODO:  Fix this
public static <T> void sort(List<T> list, Comparator<T> c) {...}
 
//NOTE: Here we take the data from the list and put it back in the list in sorted order. Hence list is used as both an "in" and an "out" variable and hence we don't use wildcards
//The comparator is supplied the value and hence it is used as an "in" variable. So we should use super keyword for comparator
//This allows us to use a Comparator of super type of X for sorting the list of type X
public static <T> void sort(List<T> list, Comparator<? super T> c) {...}
 
//TODO:  Fix this
public static <T> T min(Collection<T> collection, Comparator<T> comp) {...}
//NOTE: Here we take elements from the collection and supply it to comparator to do comparisons. So coll is a "in" variable and comp is "out" variable.
//Hence we have used extends for coll and super for comp. This allows us to use a Comparator of super type of X for finding minimum element from collection of subtype of X
static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp)
 
//TODO:  Fix this
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {...}
 
//NOTE: Here both the arguments are used to serve the value which is used to add to a new set which is union of input sets. Hence we use extends
public static <E> Set<E> union(Set<? extends E> s1, Set<? extends E> s2) {...}
12 Performance
While performance is a desirable characteristic of a program, you should not sacrifice readability of program for minor gains in performance. Programmers should factor in the cost of increased complexity while pursuing intended benefits due to better performance. You should avoid adding obvious inefficiencies in our programs by ignoring performance aspects. 

12.1 Consider the performance implications of choice of the data structures and algorithms
When you decide on the data structures to use, you should consider performance implications. For instance, if you are using contains on a collection, it may involve linear search in collections like List. 

// TODO: Fix this
// Removes all non reportable positions and logs exclusion reason
public void filterPositions(List<Position> positions) {
    List<Position> excludedPositions = new ArrayList<Position>();
    for (Position position : positions) {
        if (!isReportable(position)) {
            excludedPositions.add(position);
        }
    }
    logExclusionReason(excludedPositions);
    positions.removeAll(excludedPositions);
}
 
// NOTE: There is a hidden performance issue in above method. To remove all elements of positions matching the
// elements of excludedPositions, you would need to iterate over positions and for each element check if it is
// present in // excluded position. This is highly inefficient algorithm and completely unnecessary.
public void filterPositions(List<Position> positions) {
    List<Position> excludedPositions = new ArrayList<Position>();
    Iterator<Position> iter = positions.iterator();
    while (iter.hasNext()) {
        Position position = iter.next();
        if (!isReportable(position)) {
            iter.remove();
            excludedPositions.add(position);
        }
    }
    logExclusionReason(excludedPositions);
}
12.2 Don't ignore minor inefficiencies in statements executed large number of times
When you execute a statement larger number of times(e.g. statement in a loop), even minor inefficiencies add up to significant performance problems.  If you write a public a method, you can't tell how many times it would be called and hence it is important to remove obvious inefficiencies.Here are some examples.

Prefer StringtBuilder over String concatenation: In Java, String objects are immutable. Every change in a string using concatenation results into creation of a new String object. This may not be a problem if it is done once or twice because java compiler optimizes code to use StringBuilder. However, the optimizations would result in creation of a new StringBuilder for each concateation. Hence if you want to execute such statement a large number of times, use StringBuilder.
Avoid repeated autoboxing/unboxing of primitives: The cost associated with frequent autoboxing and unboxing of primitives can be significant and hard to detect. You need to understand how autoboxing/unboxing works and avoid frequent conversions from primitives to wrapper and vica-versa.
Prefer Prepared statements: If you want to execute a Statement object many times, it usually reduces execution time to use a PreparedStatement object. The main feature of a PreparedStatement object is that, unlike a Statement object, it is given a SQL statement when it is created. The advantage to this is that in most cases, this SQL statement is sent to the DBMS right away, where it is compiled. As a result, the PreparedStatement object contains not just a SQL statement, but a SQL statement that has been precompiled. This means that when the PreparedStatement is executed, the DBMS can just run the PreparedStatement SQL statement without having to compile it first
//TODO: Fix this
public long sum(List<Integer> numbers) {
    Long sum = 0L;
    for (Integer number : numbers) {
        sum = sum + number;
    }
    return sum;
}
 
//NOTE: Addition operation results in unboxing of sum and number variables and again autoboxing to assign the computed value to sum.
public long sum(List<Integer> numbers) {
    long sum = 0;
    for (Integer number : numbers) {
        sum = sum + number;
    }
    return sum;
}
 
// TODO: Fix this
public class CountryFilter implements Descriminator<Position> {
    // Comma separated country codes
    private final String countryCodes;
     
    private CountryFilter(String countryCodes) {
        this.countryCodes = countryCodes;
    }
     
    @Override
    public boolean accept(Position position) {
        return Arrays.asList(countryCodes.split(",")).contains(position.getCountryCode());
    }
}
 
 
// NOTE: This may not be apparent at first sight but the code above results in creation of one List per call to accept. Further, each call results in a linear search for country code.
// This should be avoided by replacing the creation of country code list with one time creation of a set of country codes.
class CountryFilter implements Descriminator<Position> {
    // Comma separated country codes
    private final Set<String> countryCodes;
     
    private CountryFilter(Set<String> countryCodes) {
        this.countryCodes = countryCodes;
    }
     
    @Override
    public boolean accept(Position position) {
        return countryCodes.contains(position.getCountryCode());
    }
}
 
Set<String> countryCodes = UnifiedSet.newSetWith(countryCodeStr.split(","));
CountryFilter filter = new CountryFilter();
12.3 Avoid creating unnecessary objects and cleanup references when no longer needed
Each Java process runs with a finite amount of memory. If you are not careful about releasing unused references, your process runs the risk of failure due to OutOfMemory error. It's a good practice to release the object references that you no longer need. Similarly, care must be taken to avoid creating unnecessary objects.

//TODO: Fix this
private static void appendSourceName(Path inputFilePath, Path outputFilePath) throws IOException {
    List<String> lines = Files.readAllLines(inputFilePath, Charset.defaultCharset());
    List<String> modifiedLines = new ArrayList<String>();
    for (String line : lines) {
        String modifiedLine = line + "," + getSourceName();
        modifiedLines.add(modifiedLine);
    }
    write(outputFilePath, modifiedLines);
} 
 
//NOTE: This above method is creating unnecessary objects and it take a lot of memory if the file is huge. Additionally, the application create Strings using concatenation which cause new strings to be created.
//Following code fixes these issues
private static void appendSourceName(Path inputFilePath, Path outputFilePath) throws IOException {
    try (BufferedReader reader = Files.newBufferedReader(inputFilePath, Charset.defaultCharset());
            BufferedWriter writer = Files.newBufferedWriter(outputFilePath, Charset.defaultCharset());) {
        String line = reader.readLine();
        while (line != null) {
            writer.append(line);
            writer.append(",").append(getSourceName());
            writer.newLine();
            line = reader.readLine();
        }
    }
}
13 Security
If your application deals with sensitive information, you should follow security best practices to minimize the likelihood of security vulnerabilities caused by programmer error. Secure Coding Guidelines for Java provides a comprehensive list of items that lead to security vulnerabilities. Here is a short list of items from the document.

Trust boundaries: In order to ensure that a system is protected, it is necessary to establish trust boundaries. Data that crosses these boundaries should be sanitized and validated before use.
Validate inputs: Input from untrusted sources must be validated before use. Maliciously crafted inputs may cause problems, whether coming through method arguments or external streams.
Avoid any untrusted data on the command line: When creating new processes, do not place any untrusted data on the command line
Do not expose modifiable collections: Developers should consider exposing read-only copies of Collections relating to security authentication or internal state.
Don't Leak Internal Structures: Error messages passed out of the system should not provide information about internal structures, such as database tables or file paths. This is true of data returned to the client, as well as external (public) APIs.
Be careful while using reflection: Be particularly careful when using APIs like Class.forName() or Runtime.exec(); these will execute (potentially) external code with your application's privileges.
Don't Put Sensitive Information in Log Files: Things like passwords or kerberos tokens don't belong in log files. Purge sensitive information from exceptions
Avoid dynamic SQL: It is well known that dynamically created SQL statements including untrusted input are subject to command injection. It is better to use a well-written, higher-level library to insulate application code from SQL
